27.9.

Hello. For a start, let’s do some lyrics.

Come writers — and critics
Who — prophesize with your pen
And keep your eyes — wide
The chance won’t — come again
And don't speak — too soon
For the wheel's still in spin —

After pressing the run button — you see the lyrics floating onto the screen. —

The web-app you see here is called clj-tiles. It is open source and hosted on GitHub pages. You can see the address here. While some more lyrics is quoted, maybe you open the web page and come along.

Change to page 10. —

And — there's no tellin' who
That it's namin’ —
For the loser now —
Will be later — to win
For the times — they are a-changin’

Make sure to connect the last line. Press run and see the lyrics. —
Go to page 11. —

For the wheel's still in spin
For the times they are a-changin’

Now watch the text rotate.

Clj-tiles is a collection of tutorials in the from of puzzles. And yes, they are all Clojure tutorials. The app uses Blockly, which is a library for graphical programming.

No software is needed to play with the puzzles. That is  other than a web-browser. No active web-server is needed. Its all Clojurescript hosted on GitHub pages.

Clj-tiles is a single page web application. There are several sections, all containing a handful of puzzles. All in all there are 13 sections and 137 puzzles. A large part of it is devoted to Physics. The culmination of all this is the modelling of the driven pendulum. 

Go to the section called “Pendulum result”. You see all kinds of rather complicated stuff. Coordinate transformations —, Lagrangian functions —, potential energy —, kinetic energy — you do not have to understand all this.  This video will carefully explain the basics. In such a way, It will not get as far to explain all this. But press run to see a nice equation —.

Now go to section 2 —
Calculate the average between 20 and 40. Drag 20 in front of 40 — and devide by 2. Press run. The result is of course 30. The code which is generated to get this result is shown on the right hand side. Here you see the first thing which might be surprising. The code which is executed is Clojure code. That means you have prefix notation. The plus sign is in front of 20 and 40. If you look at the blocks you see infix notation. The plus is between 20 and 40.

This is a design decision of clj-tiles. One reason why people do not like LISP languages is parentheses. Especially in the wrong places. There are no parentheses in the blocks, so this obstacle on the way to LISP is removed in graphical programming.

The second big reason why people find LISP awkward is the prefix notation in mathematical formulas. This is the reason why clj-tiles has infix notation. The hope is to onboard people much easier this way. As you will see, the later puzzles are physics tutorials. They are examples taken from the book Structure and Interpretation of Classical Mechanics, SICM in short. Those physics puzzles try to show to physicists the advantages of functional programming. And those people are used to read infix notation. Of course they quickly learn and accept the prefix notation, but there needs to be a bridge. This is provided here.

Infix notation is only implemented for simple expressions. Open the parser by right clicking on the workspace — and type plus one two — Press insert. You see, the parser converts this to infix notation.

Press run — the code generated is proper Clojure code in prefix notation. But by the time people work with the parser and analyse the generated code, they’ll get it. It is important to say that the code displayed is for informational purposes only. It can be completely ignored throughout. It might be handy for pasting it into a text editor to start developing your own programs.

Open the parser again — type plus one two three — insert and there you have prefix. Only simple expressions are treated in a special way.

Step back to 24 and again to 25. The puzzle is reset. You can also calculate 20 devided by two plus forty — . It is equally well. The puzzle has no forced solution. Almost no puzzle has. But if you go back to 11 and run. You see that in this case, the correct solution leads to a non standard output. But that has to be implemented separately and is the exception.

Now go to page 26. Complete the puzzle and press run. A variable called “the-average” is defined and printed. You see both the printed value and the result of the program as expected.

Reset page 26 and run —. You get an error message. It is actually not called error message but code interpretation result, because sometimes a workspace is not yet meant to run. You did not make an error, so the name “error” is simply wrong.

Right click on the number 2 and inspect. You now see three reasons why no end result is shown. The first reason being the variable “the-average” dangling on top. The second is for the ill formed def. The third again for a dangling “the-average”. There is more than one reason displayed because Inspect tries to run every expression separately. This is different from the run button which simply runs the program.

Move the number two out of its block and inspect —. All of a sudden you get a result. Clojure was able to evaluate the expression despite all the other errors. The value “two” is printed together with its type “Number”. 

Types are important. You will see this later on when you try to understand the modelling of physical theories. The display of types is possible because lots of expressions in clj-tiles are specced using Clojure Spec.

Go to 27, complete and run — The function say-welcome is called with the value “Clojure” and the text “Welcome to Clojure is printed”. To understand better what is going on, inspect the parameter called “what” —. Indeed is carries the value “Clojure” and is of type “text”.

Now go to 28. Here you can deepen your understanding of what you just learned. It is the same puzzle as before but splitted up a bit more. This means it is more difficult. You can see that the blocks have different colours depending on the number of slots. One slot is violet. Two slots is green. Three slots is blue.

The blocks are all constructed in the same way. They start with a name, “defn”, “printline” “say-welcome” and have a number of slots. The “defn” is not special in any way, it is just displayed vertically, but this can be changed for any block. Right click on “defn” and select “Inline inputs” to see this. In the same way you can have external inputs for the “printline” block. But that does not make sense from a code formatting point of view. So revert this —. All in all, Clojure leads itself perfectly to an implementation in graphical blocks.

Now solve the puzzle. Connect the variable named “what” as a parameter. Connect the “Println” to the function body. Complete the printline statement with the text “Welcome to”. Finally call the function. Press run.

Sometimes the colours play out nicely to clearly separate the different expressions, as in this case. But sometimes not. When you go forward one page — it is green all over. What helps a little is the slight upward shift in nested blocks.

This page clearly is a puzzle to learn how to program a function which calculates the average of two numbers. Some of you might have noticed that these examples are taken out of the book “Getting Clojure”.

The overall idea behind all this is that you learn by following along. There is no need to install anything and no need to type anything. There are over 100 examples. Section 1-4  cover the Clojure basics. Section 5 is devoted to simple web programming with reagent. If you got to the section called “Rocket” and run page 63, you can see the result of this effort. Launch the rocket —. The example is adapted from the book “How to Design Programs”.

If you drop down the sections menu, you see that “Rocket” is followed by “Higher Order”, but go to “Lagrangian” at first.

In what follows, maybe you are not understanding immediately what exactly is going on. The hope is that you stick longer to this video when you do something while watching. So keep moving the blocks. You learn by imitation as you solve puzzles. Maybe you are even motivated to listen to the video a second time and try to solve puzzles by only listening. One thing to mention ist, that clj-tiles is not meant for developing programs. For that a simple text editor is best.

The puzzles in the section “Lagrangian” are based on the SICM book and utilities. Originally the SICM utils are written in MIT Scheme. In the last years, the SICM utils have been ported to Clojure by Colin Smith. Sam Richie enhanced and ported them to Clojurescript. This port is used by clj-tiles. It is the reason you can follow along in the browser.

You see, this page has an explanation that should help solving the puzzle. It reads: A mathematical vector is created with the function “up”. The notion mathematical vector is a bit clunky, but it is used to make clear that this is not a usual Clojure vector. A mathematical vector is a distinct kind of object. The vector you create here is also called up-vector or column vector by mathematicians. From now on, the word vector is meant to be in this sense.

By looking at the vectors in the explanation you might guess how to solve the puzzle. The number 1 goes to the left, sine of pi is zero and goes to the upper right leaving only one place for the square root of four.

Press run — the result is (up one five nine). You can clear the output the get back to the explanation and see that you solved correctly. You learned that vectors can be added by simply using the plus sign. In standard Clojure that is not possible. In clj-tiles, the plus operator is replaced by SICM utils to make this happen.

Inspect the whole green block —. First of all, the output looks nicer. And second, you get all the type information for the result. You see that the result is a column vector which consists of three numbers. You can also inspect the blue blocks. Start with the left one —. Again a column vector with three numbers. Inspect the right blu block —. Here we get a new type: an expression. If you inspect pi, you gat a hint why this is: pi is a symbol and apparently the function sine returns an expression when fed with a symbol. Sometimes the function sine returns a number. Play around with it to find out yourself when this is.

So we already have four different kind of mathematical objects in this simple example. There are numbers and symbols, which we already know from standard Clojure. In addition you have a type “column vector” and a type “expression”. They are provided by the SICM library. All of those mathematical objects can be used in calculations. In other words: you have a computer algebra system in the browser.

Now fill the upper left slot with the green block. Press run — The result is printed nicely formatted as before but without the types. Again, all this formatting is provided by the SICM utility, it is just consumed here as a low hanging fruit.


Switch to the next page. You can complete it just by pulling all dangling blocks to the left. You crated a function which depends on time that returns a vector. Inspect the function call— the result is a simple vector of numbers. For example, the first number is four times ten plus seven, which equals 47. Inspect the parameter “time” in the function body. You see that the vector is indeed generated at time point 10. Ten seconds, say.

28.9.
Now go to page 88. Drag the symbol t onto the slot and press run. You just performed multiplications with a symbol. Inspect the parameter time in the function body. It is the symbol t as expected. Inspect the first green block in the functions body. It is the expression 4t + 7.

Clear the output and run —. What you see here is what Physicists call a time dependent vector. This vector is linear in time. There is no squares or cosines or other weird functions involved. Just t multiplied by a number. Moreover, the vector has three dimensions. Interpret the vector as a path of an object in space. You will conclude that the object flies on a straight line. Like a train moving on a straight track at constant speed. Or any object flying uninterrupted in a space shuttle. It is the simplest movement there is. It is the movement of the so called free particle. 

Now you also know the reason why the function is called test-path. Because it generates some path.

Now go to page 83. Look at the violet block. This block is of the usual form you are already used to. It has a name in its first place and one slot. The slot is filled with the string “three equals”. 

Now inspect the block —. The result of this block is a function with exactly one parameter. For comparison, go to page 85 — and look at the square of two. This is the same kind of violet block, it has only one slot as well. Inspect it. The result is a number, the number 4, you have seen that before.

Now back to page 83, evaluate the violet block again — it returns not a number but a function. You want to find out what this unnamed function with one parameter does. And for this, there is this beige-coloured block with the small closing paren in between. In its first place, there is a slot. Remember that up to now, in the first place there never was a slot, but the name of some function. The beige block is of its own kind, a very unique thing. In the first place, there needs to be a function.

Try it out and fill the slot. Press run — the result is the text “three=3”. So the string “three=“ within the violet block is concatenated to the number 3. Maybe you have already seen this kind of function acrobatics before. It goes by the name of “lambda functions”.

In any case, whenever you see this beige-colored block, you know that you have to think twice what is going on here. You are dealing with a concept that is at the heart of functional Physics. And that you are well advised to inspect all involved blocks and make sure to understand whether they return a function or something else. It helps to remember that there is only one kind of beige-colored block and that it always has exactly two slots.

Now again go to section “Lagrangian” and go to page 89 — Complete the up vector and inspect it —5—. It holds three values. The those three values describe the state of a physical object. Say, a stone.  T stands for time the stone is observed. x stands for the position of the stone at this time. vx stands for its velocity.

The violet block is a function call to L-free-particle. This function “L-free-particle” is build into the SICM library. It takes a parameter m. It is the mass of, say, a stone.

Inspect this violet block. It returns a function with exactly one parameter. As it should when being in the first slot of a beige-coloured block.

Go on and complete the puzzle and press run —2—. The result is the formula for the kinetic energy. One-half m v-squared. It is just like in the example before. There a string was concatenated to a number. Here, symbols are multiplied. The symbol m within the violet block is multiplied to vx in the blue block. So, two things are multiplied by only using functions that take not more than one parameter. This is the magic of the beige-coloured block.

Go to page 95. Complete the upper half of the puzzle. Drag square D in the first slot and sin in the second slot. Inspect the whole block —. It is a function. But which one, you ask. We need to apply it to some parameter. So, finish the puzzle —4—. The result is minus sine. You might guess that you calculated the second derivative. 

In more advanced examples like this, the beige-colored blocks are nested. The nesting is not recognisable through color. After all, a block is nested into its own kind. Because this case is so important, this closed paren is here to help you. You can easily spot the level of nesting in this way. Remember there is only one kind of beige-colored block. It is unique. It always has exactly two slots, there is no exception. In this way you now see, that the nesting is one-fold here.

Now go take another look at the result. Of what type is it? One might guess it is a function. The derivative of a function always is a function, right? That is perfectly true, but be careful what each block means. First inspect the pink sin block —. A function. Then inspect the whole block. It is not a function, it is an expression. The function you are looking for is returned by the inner beige-coloured block. Inspect it again. See - a function. This is the real second derivative of sine. An unnamed function. You only know how the derivative of sine looks like, when you apply it to some parameter. But it is important to understand that this curiosity is payed by the price that you now look at an expression. You only can take the derivative of a function. You cannot take the derivative of an expression.

Page 98 brings it all together. Complete the function straight line. It returns the time dependent vector that describes the free particle. It is the same vector as before, only the numbers are replaced by symbols —10—. 

Now look at the violet area. It generates the so called Lagrangian equation for the free particle. The equation is very simple. It is just the second derivative we have seen before. It is related to Newtons law which says acceleration is zero when there are no forces. And acceleration is defined as the second derivative by time.

So insert the straight line into the slot and run. The result is zero in each dimension. You have proven that the path indeed represents a movement on wich no forces act.
