#+begin_src clojure :exports none
(ns fdg.ch1
  (:refer-clojure :exclude [+ - * / = compare zero? ref partial
                            numerator denominator])
  (:require [sicmutils.env :as e :refer :all :exclude [F->C]]))

(define-coordinates t e/R1-rect)
#+end_src

Easy polar coordinates

#+begin_src clojure
(->tex-equation
  (up (* 'R (cos 'phi))
      (* 'R (sin 'phi))))
#+end_src

#+begin_src clojure
(->tex-equation
  (up (* 'R (sin 'theta) (cos 'phi))
          (* 'R (sin 'theta) (sin 'phi))
          (* 'R (cos 'theta))))
#+end_src

#+begin_src clojure
(->infix
  (simplify
    ((D (* 3 (expt sin 2))) 'x)))
#+end_src

#+begin_src clojure
(define ((L-free-particle mass) local)
(let ((v (velocity local)) (_ 0))
(* 1/2 mass (dot-product v v)))) 
#+end_src

#+begin_src clojure
(define q
 (up (literal-function 'x)
 (literal-function 'y)
 (literal-function 'z))) 
#+end_src

#+begin_src clojure
((Gamma q) 't) 
#+end_src

#+begin_src clojure
((compose (L-free-particle 'm) (Gamma q)) 't) 
#+end_src

#+begin_src clojure
(define (Lagrangian-action L q t1 t2)
  (definite-integral (compose L (Gamma q)) t1 t2)) 
#+end_src

#+begin_src clojure
(define (test-path t)
  (up (+ (* 4 t) 7)
      (+ (* 3 t) 5)
      (+ (* 2 t) 1))) 
#+end_src

#+begin_src clojure
(Lagrangian-action (L-free-particle 3.0)
                   test-path 0.0 10.0) 
#+end_src

#+begin_src clojure
(define ((make-eta nu t1 t2) t)
(* (- t t1) (- t t2) (nu t))) 
#+end_src

#+begin_src clojure
(define ((varied-free-particle-action mass q nu t1 t2) eps)
  (let ((eta (make-eta nu t1 t2)) (_ _))
    (Lagrangian-action (L-free-particle mass)
                       (+ q (* eps eta))
                       t1
                       t2))) 
#+end_src

#+begin_src clojure
((varied-free-particle-action 3.0 test-path
                              (up sin cos square)
                              0.0 10.0)
 0.001) 
#+end_src

#+begin_src clojure
(minimize 
  (varied-free-particle-action 3.0 test-path
   (up sin cos square)
    0.0 10.0)
  -2.0 1.0)
#+end_src

#+begin_src clojure
(define ((parametric-path-action Lagrangian t0 q0 t1 q1) qs)
  (let ((path (make-path t0 q0 t1 q1 qs)) (_ 0))
    (Lagrangian-action Lagrangian path t0 t1))) 
#+end_src

#+begin_src clojure
  (define (find-path Lagrangian t0 q0 t1 q1 n)
    (let ((initial-qs (linear-interpolants q0 q1 n)) (_ 0))
      (let ((minimizing-qs
              (multidimensional-minimize
                (parametric-path-action Lagrangian t0 q0 t1 q1)
                initial-qs))
            (_ _))
        (make-path t0 q0 t1 q1 minimizing-qs)))) 
#+end_src

#+begin_src clojure
(define ((L-harmonic m k) local)
  (let ((q (coordinate local))
        (v (velocity local)))
    (- (* 1/2 m (square v)) (* 1/2 k (square q))))) 
#+end_src

pi-half is :pi/2 in Scheme

#+begin_src clojure
(define q-harmonic 
  (find-path (L-harmonic 1.0 1.0) 0.0 1.0 pi-half 0.0 3))
#+end_src

#+begin_src clojure
(- (cos 0.8) (q-harmonic 0.8))
#+end_src 

#+begin_src clojure
(define (general-test-path t)
  (up (+ (* 'a t) 'a0)
      (+ (* 'b t) 'b0)
      (+ (* 'c t) 'c0))) 
#+end_src

#+begin_src clojure
(((Lagrange-equations (L-free-particle 'm))
  general-test-path)
 't) 
#+end_src

#+begin_src clojure
(show-expression
  (((Lagrange-equations (L-free-particle 'm))
    (literal-function 'x))
   't)) 
#+end_src

#+begin_src clojure
(define (proposed-solution t)
  (* 'A (cos (+ (* 'omega t) 'phi)))) 
#+end_src

#+begin_src clojure
(show-expression
  (((Lagrange-equations (L-harmonic 'm 'k))
    proposed-solution)
   't)) 
#+end_src

#+begin_src clojure
    (define ((L-Kepler-central-polar m V) local)
      (let ((q (coordinate local))
            (qdot (velocity local)))
        (let ((r (ref q 0))
              (phi (ref q 1))
              (rdot (ref qdot 0)) (phidot (ref qdot 1)))
          (- (* 1/2 m
                (+ (square rdot) (square (* r phidot))) )
             (V r))))) 
#+end_src

#+begin_src clojure
(define ((gravitational-energy G m1 m2) r)
  (- (/ (* G m1 m2) r))) 
#+end_src

#+begin_src clojure
(define (circle t)
  (up 'a (* 'n t))) 
#+end_src

#+begin_src clojure
(define lagrangian-reduced
(L-Kepler-central-polar (/ (* 'M_1 'm_2) (+ 'M_1 'm_2))
(gravitational-energy 'G 'M_1 'm_2))) 
#+end_src

#+begin_src clojure
(((Lagrange-equations lagrangian-reduced) circle) 't) 
#+end_src

#+begin_src clojure
(define ((L-uniform-acceleration m g) local)
  (let ((q (coordinate local))
        (v (velocity local)))
    (let ((y (ref q 1)) (_ 0))
      (- (* 1/2 m (square v)) (* m g y))))) 
#+end_src

#+begin_src clojure
(show-expression
  (((Lagrange-equations
      (L-uniform-acceleration 'm 'g))
    (up (literal-function 'x)
        (literal-function 'y)))
   't)) 
#+end_src

#+begin_src clojure
(define ((L-central-rectangular m U) local)
  (let ((q (coordinate local))
        (v (velocity local)))
    (- (* 1/2 m (square v))
       (U (sqrt (square q)))))) 
#+end_src

#+begin_src clojure
  (((Lagrange-equations
      (L-central-rectangular 'm (literal-function 'U)))
    (up (literal-function 'x)
        (literal-function 'y)))
   't) 
#+end_src

#+begin_src clojure
(show-expression
  (((Lagrange-equations
      (L-Kepler-central-polar 'm (literal-function 'U)))
    (up (literal-function 'r)
        (literal-function 'phi)))
   't)) 
#+end_src

#+begin_src clojure
(define ((F->C F) local)
  (up (time local)
      (F local)
      (+ (((partial 0) F) local)
         (* (((partial 1) F) local)
            (velocity local))))) 
#+end_src

#+begin_src clojure
(define (p->r local)
  (let ((polar-tuple (coordinate local)))
    (let ((r (ref polar-tuple 0))
          (phi (ref polar-tuple 1)))
      (let ((x (* r (cos phi)))
            (y (* r (sin phi))))
        (up x y))))) 
#+end_src

#+begin_src clojure
(show-expression
  (velocity
    ((F->C p->r)
     (up 't (up 'r 'phi) (up 'rdot 'phidot))))) 
#+end_src

#+begin_src clojure
(define (L-central-polar m U)
  (compose (L-central-rectangular m U) (F->C p->r))) 
#+end_src

#+begin_src clojure
(show-expression
  ((L-central-polar 'm (literal-function 'U))
   (up 't (up 'r 'phi) (up 'rdot 'phidot)))) 
#+end_src

    <h4>Coriolis and centrifugal forces</h4>

#+begin_src clojure
(define ((L-free-rectangular m) local)
  (let ((vx (ref (velocities local) 0))
        (vy (ref (velocities local) 1)))
    (* 1/2 m (+ (square vx) (square vy))))) 
#+end_src

#+begin_src clojure
(define (L-free-polar m)
  (compose (L-free-rectangular m) (F->C p->r))) 
#+end_src

#+begin_src clojure
(define ((F Omega) local)
  (let ((t (time local))
        (r (ref (coordinates local) 0))
        (theta (ref (coordinates local) 1)))
    (up r (+ theta (* Omega t))))) 
#+end_src

#+begin_src clojure
(define (L-rotating-polar m Omega)
  (compose (L-free-polar m) (F->C (F Omega)))) 
#+end_src

#+begin_src clojure
(define (L-rotating-rectangular m Omega)
  (compose (L-rotating-polar m Omega) (F->C r->p))) 
#+end_src

#+begin_src clojure
(define (r->p local)
  (let ((rect-tuple (coordinate local)))
    (let ((x (ref rect-tuple 0))
          (y (ref rect-tuple 1)))
       (let ((r (sqrt (square rect-tuple)))
             (phi (atan (/ y x))))
         (up r phi))))) 
#+end_src

#+begin_src clojure
((L-rotating-rectangular 'm 'Omega)
(up 't (up 'x_r 'y_r) (up 'xdot_r 'ydot_r))) 
#+end_src

#+begin_src clojure
(+ (* 1/2 (expt 'Omega 2) 'm (expt 'x_r 2))
(* 1/2 (expt 'Omega 2) 'm (expt 'y_r 2))
(* -1 'Omega 'm 'xdot_r 'y_r)
(* 'Omega 'm 'ydot_r 'x_r)
(* 1/2 'm (expt 'xdot_r 2))
(* 1/2 'm (expt 'ydot_r 2))) 
#+end_src

#+begin_src clojure
(((Lagrange-equations (L-rotating-rectangular 'm 'Omega))
  (up (literal-function 'x_r) (literal-function 'y_r)))
 't)
#+end_src

#+begin_src clojure
(define x_r (literal-function 'x_r)) 
#+end_src

#+begin_src clojure
(define y_r (literal-function 'y_r)) 
#+end_src

#+begin_src clojure
(down
(+ (* -1 (expt 'Omega 2) 'm (x_r 't))
(* -2 'Omega 'm ((D y_r) 't))
(* 'm (((expt D 2) x_r) 't)))
(+ (* -1 (expt 'Omega 2) 'm (y_r 't))
(* 2 'Omega 'm ((D x_r) 't))
(* 'm (((expt D 2) y_r) 't)))) 
#+end_src

#+begin_src clojure
(define ((T-pend m l g ys) local)
(let ((t (time local) (_ 0))
(theta (coordinate local))
(thetadot (velocity local)))
(let ((vys (D ys)) (_ 0))
(* 1/2 m
(+ (square (* l thetadot))
(square (vys t))
(* 2 l (vys t) thetadot (sin theta))))))) 
#+end_src

#+begin_src clojure
(define ((V-pend m l g ys) local)
(let ((t (time local))
      (theta (coordinate local)))
  (* m g (- (ys t) (* l (cos theta)))))) 
#+end_src

#+begin_src clojure
(define L-pendulum (- T-pend V-pend)) 
#+end_src

#+begin_src clojure
(show-expression
(((Lagrange-equations
(L-pendulum 'm 'l 'g (literal-function 'y_s)))
(literal-function 'theta))
't)) 
#+end_src

#+begin_src clojure
(define ((L-uniform-acceleration m g) local)
  (let ((q (coordinate local))
        (v (velocity local)))
     (let ((y (ref q 1)) (_ 0))
       (- (* 1/2 m (square v)) (* m g y)))))
#+end_src

#+begin_src clojure
(define ((dp-coordinates l y_s) local)
(let ((t (time local) (_ 0))
(theta (coordinate local)))
(let ((x (* l (sin theta)))
      (y (- (y_s t) (* l (cos theta)))))
(up x y)))) 
#+end_src
