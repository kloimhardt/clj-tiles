#+begin_src clojure :exports none
(ns fdg.ch1
  (:refer-clojure :exclude [+ - * / = compare zero? ref partial
                            numerator denominator])
  (:require [sicmutils.env :as e :refer :all :exclude [F->C]]))

(define-coordinates t e/R1-rect)
#+end_src

Easy polar coordinates

#+begin_src clojure
(->tex-equation
  (up (* 'R (cos 'phi))
      (* 'R (sin 'phi))))
#+end_src

#+begin_src clojure
(->tex-equation
  (up (* 'R (sin 'theta) (cos 'phi))
          (* 'R (sin 'theta) (sin 'phi))
          (* 'R (cos 'theta))))
#+end_src

#+begin_src clojure
(->infix
  (simplify
    ((D (* 3 (expt sin 2))) 'x)))
#+end_src

#+begin_src clojure
(define ((L-free-particle mass) local)
(let ((v (velocity local)) (_ 0))
(* 1/2 mass (dot-product v v))))
#+end_src

#+begin_src clojure
(define q
 (up (literal-function 'x)
 (literal-function 'y)
 (literal-function 'z)))
#+end_src

#+begin_src clojure
((Gamma q) 't)
#+end_src

#+begin_src clojure
((compose (L-free-particle 'm) (Gamma q)) 't)
#+end_src

#+begin_src clojure
(define (Lagrangian-action L q t1 t2)
  (definite-integral (compose L (Gamma q)) t1 t2))
#+end_src

#+begin_src clojure
(define (test-path t)
  (up (+ (* 4 t) 7)
      (+ (* 3 t) 5)
      (+ (* 2 t) 1)))
#+end_src

#+begin_src clojure
(Lagrangian-action (L-free-particle 3.0)
                   test-path 0.0 10.0)
#+end_src

#+begin_src clojure
(define ((make-eta nu t1 t2) t)
(* (- t t1) (- t t2) (nu t)))
#+end_src
