#+begin_src clojure :exports none
(ns tutorial
  (:refer-clojure :exclude [+ - * / = compare zero? ref partial
                                            time numerator denominator])
  (:require [sicmutils.env :as e :refer :all :exclude [F->C]]))
#+end_src

* Tutorial Page 1/2

(0) https://kloimhardt.github.io/markus.html#a for general information

(1) The most important thing is the left arrow "<" button. It brings you back to this tutorial.

(2) Go to the next page with ">". (back with "<")

(3) Scroll down. Do not miss some tutorial step at the bottom left or top right!

(4) Execute this workspace with "Run". (back with "<")

(5) You just saw some formula for polar coordinates. Have you memorized it? Let's find out!

(6) Press "Get the Puzzle". (back with "<")

(7) "Get the Puzzle" but come back via "Run" + "Clear output".

(8) In the workspace above, you should see several blocks containing white slots.

(9) Press "Run" and hold the "Color" button. (back via "Clear output")

(10) On the top of the workspace, put "phi" into the slot of "sin".

(11) Repeat step (9), the "(sin 'phi)" line should turn green.

(12) Make the lines more and more green by solving the workspace puzzle (keep pressing "Color"!). The code below might help.  When upon completion the ">" button turns green, press it immediately.

#+begin_src clojure
(->tex-equation
  (up (* 'R (cos 'phi))
      (* 'R (sin 'phi))))
#+end_src

#+begin_src clojure :exports none
  (defn walk [inner outer form]
    (cond
      (list? form) (outer (apply list (map inner form)))
      (seq? form)  (outer (doall (map inner form)))
      (coll? form) (outer (into (empty form) (map inner form)))
      :else        (outer form)))
  (defn postwalk [f form]
    (walk (partial postwalk f) f form))
  (defn postwalk-replace [smap form]
    (postwalk (fn [x] (if (contains? smap x) (smap x) x)) form))
  (defmacro let-scheme [b & e]
    (concat (list 'let (into [] (apply concat b))) e))
  (defmacro define-1 [h & b]
    (let [body (postwalk-replace {'let 'let-scheme} b)]
      (if (coll? h)
        (if (coll? (first h))
          (list 'defn (ffirst h) (into [] (rest (first h)))
                (concat (list 'fn (into [] (rest h))) body))
          (concat (list 'defn (first h) (into [] (rest h)))
                  body))
        (concat (list 'def h) body))))
  (defmacro define [h & b]
    (if (and (coll? h) (= (first h) 'tex-inspect))
      (list 'do
            (concat ['define-1 (second h)] b)
            h)
      (concat ['define-1 h] b)))
  (defmacro lambda [h b]
    (list 'fn (into [] h) b))
  (def show-expression simplify)
  (def velocities velocity)
  (def coordinates coordinate)
  (def vector-length count)
  (defn time [state] (first state))
#+end_src

* Tutorial Page 2/2

(1) Notice that the drop down list above shows a second chapter named "Lyrics".

(2) Press ">" a few times and note the generic text. Read it. (back to this page with "<")

(3) From this page, after having pressed "Get the Puzzle" + "Color", again press ">".

(4) Via the drop down, go to the chaper "Lyrics", press "<"+ "Color" + ">".

#+begin_src clojure
"Tutorial Page 2/2"
#+end_src

* Description

This page shows an example of calculating cartesian coordinates out of polar coordinates
in three dimensions. Press "Run" to look at some nice rendering of the result.

Note that "Get the puzzle" does not completely explode the blocks but keeps a some intact (here, contrary to the next puzzle, using :tiles/keep that unfortunately stays in the puzzle)

 $up$ : (x, y, z) $\rightarrow$ vector ; gives a three dimensional vector; the vector is just data. Having now data, we come to functions.

** Code

#+begin_src clojure
(->tex-equation
  (up (* 'R (sin 'theta) (:tiles/keep (cos 'phi)))
          (:tiles/keep (* 'R (sin 'theta) (sin 'phi)))
          (* 'R (cos 'theta))))
#+end_src

Here we show how to integrate a simple function.

Note that :tiles/keep keeps the define blocks intact and, being used at top-level, does not show up in the puzzle.

 $expt$ : (fn, number) $\rightarrow$ fn . So expt returns a function, not a number.

 $D$ :  $(fn) \rightarrow$ $fn$ ; a procedure that takes a function of one number and returns a function which is the derivative.

(( $D$ (* 3 (expt sin 2))) 'x))) : the expression 6 sin(x) cos(x) ; an expression is just data. Note that with D, the derivative is taken from a function and not perhaps from some expression.

#+begin_src clojure
(:tiles/keep (define t0 0))
(:tiles/keep (define t1 10))
(definite-integral (expt sin 2) t0 t1)
#+end_src

#+begin_src clojure
(define t 't_i)
(define mass 'm_0)
(->infix
  (simplify
    ((D (* mass (expt sin 2))) t)))
#+end_src

* Description

 $literal-function$ : (symbol) $\rightarrow$ fn ; returns a generic function of one argument

 $x$ : the path function; it is a generic function which here represents a point at position x at time t; can be viewed as $x(t)$, a function of $t$.

 $Gamma$ : (path-fn) $\rightarrow$ fn ; a procedure that takes a path function and returns a somewhat augmentd path-function

 $gamma-of-x$ : a function; $(t) \rightarrow$ local-tuple  ; generated by the Gamma procedure

 $local$ : the local tuple (t, x(t), v(t))

** ---
Scheme replacement: replace () in all let expressions with []
in principle, a :tiles/vert would alaways be in order (only done in a view examples)
(let ((x a)) (f x)) -> (let (:tiles/vert [(:tiles/vert (x a))]) (f x))

** Code

#+begin_src clojure
(define x (literal-function 'x))
(define gamma-of-x (Gamma x))
(define local (gamma-of-x t))
(->tex-equation local)
#+end_src


* 1 Lagrangian Mechanics

** 1.4 Computing Actions

 $L-free-particle$ : $(mass) \rightarrow$ $fn$ ; procedure that takes a mass and returns a function

( $L-free-particle$ 'm) : $(local) \rightarrow$ mv^2/2

#+begin_src clojure
(define ((L-free-particle mass) local)
    (let [(:tiles/vert (v (velocity local)))]
      (* 1/2 mass (dot-product v v))))
#+end_src

#+begin_src clojure
(define q
 (up (literal-function 'x)
 (literal-function 'y)
 (literal-function 'z)))
((Gamma q) 't)
#+end_src

 $compose$ : (fn, fn) $\rightarrow$ fn ; makes a new function out of two functions

#+begin_src clojure
((compose (L-free-particle 'm) (Gamma q)) 't) 
#+end_src

#+begin_src clojure
(define (test-path t)
  (up (+ (* 4 t) 7)
      (+ (* 3 t) 5)
      (+ (* 2 t) 1)))
#+end_src

 $Lagrangian-action$ : (Lagrange-Function, path, t0, t1) $\rightarrow$ number ; a numerical calculation of the action of a given path.

#+begin_src clojure
(define (Lagrangian-action L q t0 t1)
  (definite-integral (compose L (Gamma q)) t0 t1))
(define Lagrangian (L-free-particle 3.0))
(Lagrangian-action Lagrangian test-path 0.0 10.0)
#+end_src

Note that by construction, make-eta is zero if t is either 0 or 10.

#+begin_src clojure
(define nu (up sin cos square))
(define ((make-eta nu t0 t1) t)
(* (- t t0) (- t t1) (nu t)))
#+end_src

#+begin_src clojure
(define ((varied-free-particle-action mass q nu t0 t1) eps)
  (let [(:tiles/vert (eta (make-eta nu t0 t1)))]
    (Lagrangian-action (L-free-particle mass)
                       (+ q (* eps eta))
                       t0
                       t1)))
((varied-free-particle-action 3.0 test-path nu 0.0 10.0) 0.001)
 #+end_src

#+begin_src clojure
((varied-free-particle-action 3.0 test-path
                              (up sin cos square)
                              0.0 10.0)
 0.001) 
#+end_src

#+begin_src clojure
(minimize 
  (varied-free-particle-action 3.0 test-path
   (up sin cos square)
    0.0 10.0)
  -2.0 1.0)
#+end_src

 $make-path$ : (t0, q0, t1, q1, positions) $\rightarrow$ fn(t) ; construct a path by linear inperpolation between the positions. Unlike test-path, the path is not three dimensional but rather one-dimensional.

#+begin_src clojure
(define q0 0)
(define q1 5)
(define qs (up -1 2 -3 4))
((make-path t0 q0 t1 q1 qs) 6.1)
#+end_src
